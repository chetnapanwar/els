[
    {
        "id": "js_async_01",
        "topic": "Async - Promise States",
        "question": "Which of the following is NOT a valid state for a JavaScript Promise?",
        "options": [
            "fulfilled",
            "rejected",
            "pending",
            "resolved"
        ],
        "answer": "resolved",
        "explanation": "Strictly speaking, the three states are 'pending', 'fulfilled', and 'rejected'. 'Resolved' is often used colloquially or refers to a Promise that has been 'settled' or locked into the state of another Promise."
    },
    {
        "id": "js_async_02",
        "topic": "Async - Promise.all vs Promise.allSettled",
        "question": "If you have 10 promises and one fails, what is the key difference between `Promise.all` and `Promise.allSettled`?",
        "options": [
            "Promise.all rejects immediately; allSettled waits for all to complete and returns an array of results/errors.",
            "Promise.all returns the successful ones; allSettled returns the failure.",
            "allSettled is faster.",
            "They are identical."
        ],
        "answer": "Promise.all rejects immediately; allSettled waits for all to complete and returns an array of results/errors.",
        "explanation": "Promise.all is 'fail-fast'. Promise.allSettled ensures you get the outcome of every single promise regardless of success or failure."
    },
    {
        "id": "js_async_03",
        "topic": "Async - Top-level Await",
        "question": "Where is top-level await allowed in modern environments?",
        "options": [
            "Inside ES Modules",
            "Inside any script tag",
            "Inside regular function bodies",
            "Only in Node.js version 10"
        ],
        "answer": "Inside ES Modules",
        "explanation": "Top-level await is a feature of the ECMAScript Module (ESM) specification. It allows using await at the top level of a module script."
    },
    {
        "id": "js_async_04",
        "topic": "Async - Generator Delegation",
        "question": "What syntax is used for generator delegation, allowing one generator to yield all values from another?",
        "options": [
            "yield* otherGen()",
            "yield from otherGen()",
            "yield ...otherGen()",
            "delegate otherGen()"
        ],
        "answer": "yield* otherGen()",
        "explanation": "The `yield*` operator is used to delegate to another generator or iterable object."
    },
    {
        "id": "js_async_05",
        "topic": "Async - Async Iterators",
        "question": "Which loop syntax is used to consume an object that implements `Symbol.asyncIterator`?",
        "options": [
            "for await (const x of iterable)",
            "for (const x of iterable)",
            "while (await iterable.next())",
            "iterable.forEach(async x => ...)"
        ],
        "answer": "for await (const x of iterable)",
        "explanation": "The `for await...of` loop is specifically designed to work with async iterators."
    },
    {
        "id": "js_async_06",
        "topic": "Async - Threading",
        "question": "Does `await` block the entire operating system thread?",
        "options": [
            "No, it only pauses the execution of the async function, allowing the event loop to process other tasks.",
            "Yes, it is a synchronous wait.",
            "Yes, but only in Node.js.",
            "No, it creates a new thread for the remaining code."
        ],
        "answer": "No, it only pauses the execution of the async function, allowing the event loop to process other tasks.",
        "explanation": "JavaScript is single-threaded (mostly). Await is non-blocking to the main thread; it yields control back to the event loop."
    },
    {
        "id": "js_async_07",
        "topic": "Async - Promise Constructor",
        "question": "What happens if you throw an error inside the executor function of a new Promise?",
        "options": [
            "The promise is automatically rejected with that error.",
            "The program crashes immediately.",
            "The error is ignored.",
            "A syntax error is thrown."
        ],
        "answer": "The promise is automatically rejected with that error.",
        "explanation": "The Promise executor has an implicit try-catch; any thrown error is caught and passed to the reject() callback."
    },
    {
        "id": "js_async_08",
        "topic": "Async - Microtask Priority",
        "question": "What is the result?\n\nsetTimeout(() => console.log('1'), 0);\nPromise.resolve().then(() => console.log('2'));",
        "options": [
            "2 then 1",
            "1 then 2",
            "Simultaneous",
            "Random order"
        ],
        "answer": "2 then 1",
        "explanation": "The Promise's .then() callback is a microtask, which has higher priority and runs before the next macrotask (setTimeout)."
    },
    {
        "id": "js_async_09",
        "topic": "Async - Generators Return",
        "question": "What is the result of `g.next()` after a generator has executed a `return` statement?",
        "options": [
            "{ value: returnedValue, done: true }",
            "{ value: undefined, done: true }",
            "It throws an error.",
            "It restarts the generator."
        ],
        "answer": "{ value: returnedValue, done: true }",
        "explanation": "The return statement in a generator sets the value and marks the iterator as done."
    },
    {
        "id": "js_async_10",
        "topic": "Async - Cancelling Promises",
        "question": "Which native API is now the standard way to provide 'cancellation' signals to async operations like `fetch`?",
        "options": [
            "AbortController",
            "Promise.cancel()",
            "StopSignal",
            "FetchStopper"
        ],
        "answer": "AbortController",
        "explanation": "AbortController (and its AbortSignal) is the standard web API used to communicate cancellation to async tasks."
    }
]