[
    {
        "id": "cpp_meta_01",
        "topic": "Metaprogramming - SFINAE",
        "level": 5,
        "question": "What does SFINAE (Substitution Failure Is Not An Error) specifically mean during the C++ template instantiation process?",
        "options": [
            "If a substitution of a template parameter results in an invalid type or expression, the compiler ignores that specialization instead of raising a hard error.",
            "The compiler continues to compile but skips the failing function body.",
            "The linker resolves the failure by looking for comparable types in other modules.",
            "It allows for dynamic typing in C++ via templates."
        ],
        "answer": "If a substitution of a template parameter results in an invalid type or expression, the compiler ignores that specialization instead of raising a hard error.",
        "explanation": "SFINAE is crucial for function overloading based on type properties. It allows the compiler to discard invalid candidates during overload resolution without stopping the build."
    },
    {
        "id": "cpp_meta_02",
        "topic": "Metaprogramming - Concepts",
        "level": 5,
        "question": "In C++20, what is the primary advantage of using `concepts` (e.g., `template <FloatingPoint T>`) over SFINAE with `std::enable_if`?",
        "options": [
            "Better compiler error messages, improved compilation speed, and more readable syntax.",
            "Concepts allow templates to be compiled into binary code before instantiation.",
            "Concepts can only be used with class templates, whereas SFINAE is for functions.",
            "There is no performance or developer experience difference."
        ],
        "answer": "Better compiler error messages, improved compilation speed, and more readable syntax.",
        "explanation": "Concepts provide a declarative way to constrain templates. When a constraint is not met, the compiler can give a concise error (e.g., 'type int does not satisfy FloatingPoint') instead of thousands of lines of template substitution backtraces."
    },
    {
        "id": "cpp_meta_03",
        "topic": "Metaprogramming - CRTP",
        "level": 5,
        "question": "What is the Curiously Recurring Template Pattern (CRTP) primarily used for in C++?",
        "options": [
            "Static polymorphism (achieving polymorphic behavior without virtual function runtime overhead).",
            "Implementing recursive functions at compile time.",
            "Reducing the memory footprint of objects.",
            "Enabling true multiple inheritance in C."
        ],
        "answer": "Static polymorphism (achieving polymorphic behavior without virtual function runtime overhead).",
        "explanation": "CRTP involves a class `Derived` inheriting from `Base<Derived>`. This allows the base class to call methods on the derived class using a static cast, avoiding vtable lookups and enabling better inlining."
    },
    {
        "id": "cpp_meta_04",
        "topic": "Metaprogramming - Variadic Templates",
        "level": 5,
        "question": "How do C++17 'Fold Expressions' simplify variadic template expansion?",
        "options": [
            "They allow applying a binary operator to a parameter pack without requiring recursive template instantiation.",
            "They provide a way to fold the code size of the binary.",
            "They allow folding multiple templates into a single class.",
            "They are a tool for pre-processor macro expansion."
        ],
        "answer": "They allow applying a binary operator to a parameter pack without requiring recursive template instantiation.",
        "explanation": "Prior to C++17, summing a pack `(Args... args)` required a base case and a recursive template. With fold expressions, you can simply write `return (... + args);`."
    },
    {
        "id": "cpp_meta_05",
        "topic": "Metaprogramming - Dependent Names",
        "level": 5,
        "question": "Why is the `typename` keyword required when referring to a nested type inside a template (e.g., `typename T::value_type`)?",
        "options": [
            "Because the compiler doesn't know if `T::value_type` is a type or a static member/variable until instantiation.",
            "To tell the compiler to allocate the type on the heap.",
            "It is a hint to the optimizer to treat the type as a primitive.",
            "It is only required for legacy C++ compatibility."
        ],
        "answer": "Because the compiler doesn't know if `T::value_type` is a type or a static member/variable until instantiation.",
        "explanation": "In a template, `T::name` is a 'dependent name'. By default, the compiler assumes it's a value. `typename` explicitly tells the compiler it represents a type name."
    },
    {
        "id": "cpp_meta_06",
        "topic": "Metaprogramming - constexpr if",
        "level": 5,
        "question": "What is the unique property of `if constexpr` introduced in C++17?",
        "options": [
            "The branch that is not taken is not even instantiated or checked for syntax (beyond basic validity).",
            "It makes the boolean condition faster at runtime.",
            "It allows using runtime variables in compile-time checks.",
            "It only works inside constructors."
        ],
        "answer": "The branch that is not taken is not even instantiated or checked for syntax (beyond basic validity).",
        "explanation": "`if constexpr` allows for compile-time branching. This is powerful for generic programming where one branch might contain code that would be semantically invalid for certain types."
    },
    {
        "id": "cpp_meta_07",
        "topic": "Metaprogramming - Template Template Parameters",
        "level": 5,
        "question": "What does a 'Template Template Parameter' allow you to do?",
        "options": [
            "Pass a class template (not just a type) as an argument to another template.",
            "Create a template that can only be used by other templates.",
            "Inherit from two different versions of the same template simultaneously.",
            "Define a template inside a function body."
        ],
        "answer": "Pass a class template (not just a type) as an argument to another template.",
        "explanation": "Example: `template <template <typename> class Container> class MyWrapper;`. This allows `MyWrapper` to instantiate the `Container` with its own choice of types later."
    },
    {
        "id": "cpp_meta_08",
        "topic": "Metaprogramming - Integral Constant",
        "level": 5,
        "question": "What is the standard 'Meta-function' pattern in C++ (similar to `std::is_integral<T>`)?",
        "options": [
            "A struct with a nested `static constexpr bool value` and a nested `typedef type`.",
            "A function that returns a boolean at runtime.",
            "A macro that checks types using `__builtin_types`.",
            "A class that inherits from `std::void_t`."
        ],
        "answer": "A struct with a nested `static constexpr bool value` and a nested `typedef type`.",
        "explanation": "Following the convention of `std::integral_constant`, meta-functions export their results via `::value` for values and `::type` for types."
    },
    {
        "id": "cpp_meta_09",
        "topic": "Metaprogramming - ADL (Argument Dependent Lookup)",
        "level": 5,
        "question": "How can ADL lead to 'Customization Point' vulnerabilities in generic code, and how does the 'non-ADL' call pattern fix it?",
        "options": [
            "ADL might find an unintended function in a different namespace; solved by using `(swap)(a, b)` or a wrapper struct.",
            "ADL prevents the compiler from finding built-in types.",
            "ADL is always safer than explicit qualification.",
            "ADL only works for classes in the global namespace."
        ],
        "answer": "ADL might find an unintended function in a different namespace; solved by using `(swap)(a, b)` or a wrapper struct.",
        "explanation": "Unqualified calls like `swap(a, b)` use ADL. To avoid hijacking while still allowing specialized versions, modern C++ uses 'Niebloids' or explicit tag-dispatching patterns."
    },
    {
        "id": "cpp_meta_10",
        "topic": "Metaprogramming - Type Erasure",
        "level": 5,
        "question": "In libraries like `std::any` or `std::function`, how is 'Type Erasure' typically implemented?",
        "options": [
            "Using a combination of a templated constructor and a non-templated base class with virtual functions.",
            "Using `void*` and manual type casting everywhere.",
            "Using C-style unions exclusively.",
            "By storing the source code as a string and re-compiling it."
        ],
        "answer": "Using a combination of a templated constructor and a non-templated base class with virtual functions.",
        "explanation": "The 'External Polymorphism' pattern allows an object to store any type that satisfies a specific interface, hiding the template details from the user-facing type binary."
    }
]