[
    {
        "id": "cpp_mem_01",
        "topic": "Memory - Custom Allocators",
        "level": 5,
        "question": "When implementing a custom C++ allocator for a container like `std::vector`, what is the primary purpose of the `rebind` structure (pre-C++11) or the requirement to handle `pointer` types?",
        "options": [
            "To allow the container to allocate internal nodes (like in `std::list`) while using the user-provided allocator type.",
            "To optimize memory fragmentation automatically.",
            "To ensure that the allocator is thread-safe for all containers.",
            "To facilitate type-casting between different object sizes in the heap."
        ],
        "answer": "To allow the container to allocate internal nodes (like in `std::list`) while using the user-provided allocator type.",
        "explanation": "Containers like `std::list` need to allocate nodes, not just the object types. The `rebind` mechanism allows an allocator for `T` to be transformed into an allocator for `Node<T>`. In modern C++11+, this is mostly handled by `allocator_traits`."
    },
    {
        "id": "cpp_mem_02",
        "topic": "Memory - Cache Alignment",
        "level": 5,
        "question": "In a high-performance C++ application, what is 'False Sharing' and how is it mitigated using C++17 features?",
        "options": [
            "It occurs when two threads cache different variables that happen to reside on the same cache line; it is mitigated by `alignas(std::hardware_destructive_interference_size)`.",
            "A race condition where two pointers point to the same memory address; mitigated by `std::atomic_ref`.",
            "When memory is incorrectly freed twice; mitigated by `std::unique_ptr`.",
            "Inefficient branch prediction; mitigated by `[[likely]]` and `[[unlikely]]`."
        ],
        "answer": "It occurs when two threads cache different variables that happen to reside on the same cache line; it is mitigated by `alignas(std::hardware_destructive_interference_size)`.",
        "explanation": "False sharing causes the CPU to invalidate cache lines frequently across cores. C++17 introduced `std::hardware_destructive_interference_size` to provide the minimum offset between objects to avoid this cache line contention."
    },
    {
        "id": "cpp_mem_03",
        "topic": "Memory - Placement New",
        "level": 5,
        "question": "What is the correct way to destroy an object created with 'placement new' (`new (buffer) T()`)?",
        "options": [
            "Explicitly call the destructor: `ptr->~T();`",
            "Use `delete ptr;`",
            "Use `free(buffer);`",
            "Objects created with placement new are destroyed automatically when the buffer goes out of scope."
        ],
        "answer": "Explicitly call the destructor: `ptr->~T();`",
        "explanation": "Placement new does not allocate memory; it only calls the constructor. Therefore, `delete` cannot be used because it would attempt to deallocate memory that wasn't allocated with a standard `new`. The destructor must be called manually."
    },
    {
        "id": "cpp_mem_04",
        "topic": "Memory - Smart Pointer Internals",
        "level": 5,
        "question": "What is the memory layout difference between `std::shared_ptr<T>(new T())` and `std::make_shared<T>()`?",
        "options": [
            "`std::make_shared` allocates the object and the control block in a single contiguous block; the separate `new` version performs two distinct allocations.",
            "`std::make_shared` stores the object on the stack for optimization.",
            "The separate `new` version is faster because it avoids the control block.",
            "There is no difference in memory allocation behavior."
        ],
        "answer": "`std::make_shared` allocates the object and the control block in a single contiguous block; the separate `new` version performs two distinct allocations.",
        "explanation": "`std::make_shared` is more efficient (single allocation) and improves cache locality. However, it can leak memory if `weak_ptr`s survive long after the `shared_ptr` is gone, as the whole block cannot be freed until the reference count in the control block is zero."
    },
    {
        "id": "cpp_mem_05",
        "topic": "Memory - Overaligned Types",
        "level": 5,
        "question": "In C++17, how does the compiler handle `new` for over-aligned types (e.g., SIMD types with `alignas(64)`)?",
        "options": [
            "It uses 'aligned new', calling `operator new(size_t, align_val_t)` to ensure proper alignment.",
            "It ignores alignment and uses standard `malloc` internally.",
            "It throws `std::bad_alloc` if alignment is greater than 16 bytes.",
            "It only supports over-alignment on the stack."
        ],
        "answer": "It uses 'aligned new', calling `operator new(size_t, align_val_t)` to ensure proper alignment.",
        "explanation": "Prior to C++17, over-aligned types had undefined behavior with `new`. C++17 introduced alignment-aware allocation overloads for `operator new`."
    },
    {
        "id": "cpp_mem_06",
        "topic": "Memory - Virtual Destructors",
        "level": 5,
        "question": "What happens if a derived class object is deleted through a pointer to a base class that DOES NOT have a virtual destructor?",
        "options": [
            "The behavior is strictly undefined (UB); typically the derived destructor is never called.",
            "The derived destructor is called, but memory is leaked.",
            "A compiler error 'Non-virtual destructor' occurs.",
            "The base destructor handles derived member cleanup automatically."
        ],
        "answer": "The behavior is strictly undefined (UB); typically the derived destructor is never called.",
        "explanation": "Standard C++ treats this as Undefined Behavior. In practice, the derived part of the object is never cleaned up, leading to resource leaks."
    },
    {
        "id": "cpp_mem_07",
        "topic": "Memory - SBO (Small Buffer Optimization)",
        "level": 5,
        "question": "How does Small Buffer Optimization (SBO) in `std::string` or `std::function` affect performance and memory tracking?",
        "options": [
            "It avoids heap allocation for small payloads by storing them in a fixed-size internal buffer within the object itself.",
            "It compresses the data using a Huffman-like algorithm.",
            "It uses `mmap` for strings longer than 15 characters.",
            "It forces all strings to be exactly 32 bytes in length."
        ],
        "answer": "It avoids heap allocation for small payloads by storing them in a fixed-size internal buffer within the object itself.",
        "explanation": "SBO eliminates the latency of a heap allocation for small objects. This means the object size is slightly larger on the stack, but execution is faster for small data."
    },
    {
        "id": "cpp_mem_08",
        "topic": "Memory - PMR (Polymorphic Memory Resources)",
        "level": 5,
        "question": "What is the primary advantage of C++17's `std::pmr::vector` over a standard `std::vector`?",
        "options": [
            "It allows changing the memory allocation strategy at runtime without changing the type of the vector.",
            "It automatically synchronizes access across multiple threads.",
            "It is guaranteed to be 2x faster for all operations.",
            "It supports 128-bit integers natively."
        ],
        "answer": "It allows changing the memory allocation strategy at runtime without changing the type of the vector.",
        "explanation": "Standard vectors have the allocator as part of the type signature. PMR uses a virtual base class (`memory_resource`), meaning `vector<T>` using different allocators (pool, stack, heap) all share the same binary type."
    },
    {
        "id": "cpp_mem_09",
        "topic": "Memory - Flexible Array Members",
        "level": 5,
        "question": "In C, what is the standard way to implement a header-plus-payload structure where the payload size is determined at runtime?",
        "options": [
            "Using a zero-length array or incomplete array at the end of the struct: `int payload[];`",
            "Using `void* payload;` and a separate `malloc` for the payload.",
            "Defining the struct with a large fixed array and shrinking it.",
            "C does not support runtime-sized structures."
        ],
        "answer": "Using a zero-length array or incomplete array at the end of the struct: `int payload[];`",
        "explanation": "This is known as a Flexible Array Member (FAM). It allows the struct and payload to be allocated in a single contiguous block with one `malloc` call."
    },
    {
        "id": "cpp_mem_10",
        "topic": "Memory - Restricted Pointers",
        "level": 5,
        "question": "In C99, what optimization does the `restrict` keyword enable for the compiler?",
        "options": [
            "It promises that for the lifetime of the pointer, only that pointer (or pointers derived from it) will access the object it points to, allowing better vectorization and reordering.",
            "It prevents the pointer from being modified (making it a constant pointer).",
            "It ensures the pointer is always 16-byte aligned.",
            "It automatically checks for NULL before dereferencing."
        ],
        "answer": "It promises that for the lifetime of the pointer, only that pointer (or pointers derived from it) will access the object it points to, allowing better vectorization and reordering.",
        "explanation": "The `restrict` keyword helps solve the 'pointer aliasing' problem, where the compiler might otherwise be forced to reload values from memory repeatedly because it worries another pointer might have changed them."
    }
]