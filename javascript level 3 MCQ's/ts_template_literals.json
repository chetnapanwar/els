{
  "message": "Development-Programming Fundamentals - Ts Template Literals",
  "questions": [
    {
      "id": "ts_tl_01",
      "topic": "Template Literals - String Manipulation",
      "question": "What is the result of `type GetterName<T extends string> = `get${Capitalize<T>}`; type Res = GetterName<'name'>;`?",
      "options": [
        "\"getName\"",
        "\"getname\"",
        "\"Getname\"",
        "string"
      ],
      "answer": "\"getName\"",
      "explanation": "TypeScript provides intrinsic string manipulation types like `Capitalize`, `Uncapitalize`, `Uppercase`, and `Lowercase` that can be used within template literal types."
    },
    {
      "id": "ts_tl_02",
      "topic": "Template Literals - Unions",
      "question": "If `type T = 'a' | 'b'` and `type U = '1' | '2'`, what is the resulting union of `` `${T}_${U}` ``?",
      "options": [
        "\"a_1\" | \"a_2\" | \"b_1\" | \"b_2\"",
        "\"a_1\" | \"b_2\"",
        "string",
        "\"a_b_1_2\""
      ],
      "answer": "\"a_1\" | \"a_2\" | \"b_1\" | \"b_2\"",
      "explanation": "Template literals are distributive over unions. If multiple placeholders are used, the result is the Cartesian product of all union members."
    },
    {
      "id": "ts_tl_03",
      "topic": "Template Literals - Key Remapping",
      "question": "How do you use template literals to remap object keys to be prefixed with 'on' and capitalized, e.g., 'click' -> 'onClick'?",
      "options": [
        "type EventHandlers<T> = { [K in keyof T as `on${Capitalize<string & K>}`]: T[K] }",
        "type EventHandlers<T> = { [K as `on${K}` in keyof T]: T[K] }",
        "type EventHandlers<T> = T as `on${Capitalize<T>}`",
        "Template literals cannot be used in mapped types."
      ],
      "answer": "type EventHandlers<T> = { [K in keyof T as `on${Capitalize<string & K>}`]: T[K] }",
      "explanation": "The 'as' clause in a mapped type combined with template literals and Capitalize allows for powerful key transformations."
    },
    {
      "id": "ts_tl_04",
      "topic": "Template Literals - Pattern Matching",
      "question": "Can template literals be used in the 'extends' clause of a conditional type for pattern matching?",
      "options": [
        "Yes, e.g., `T extends `v${infer Major}.${infer Minor}` ? Major : never`",
        "No, only for creating new strings.",
        "Only for simple prefixes.",
        "Only in TypeScript 5.0+."
      ],
      "answer": "Yes, e.g., `T extends `v${infer Major}.${infer Minor}` ? Major : never`",
      "explanation": "TypeScript can perform pattern matching on template literal types, allowing you to parse strings at the type level."
    },
    {
      "id": "ts_tl_05",
      "topic": "Template Literals - Inference",
      "question": "What happens if a template literal pattern is ambiguous, like `` `${infer A}${infer B}` `` on the string 'abc'?",
      "options": [
        "A will infer the first character, and B will infer the rest.",
        "A will infer the rest, and B will infer the last character.",
        "It throws a compiler error.",
        "It returns 'never'."
      ],
      "answer": "A will infer the first character, and B will infer the rest.",
      "explanation": "When matching against template literals, TypeScript is 'greedy' from the right, meaning the first 'infer' captures the minimum possible (usually one character if ambiguous from the left)."
    },
    {
      "id": "ts_tl_06",
      "topic": "Template Literals - Recursive Manipulation",
      "question": "How can you create a type that converts a CamelCase string to snake_case?",
      "options": [
        "By using recursive conditional types with template literals to find uppercase letters and insert an underscore.",
        "By using the intrinsic `SnakeCase` type.",
        "It is impossible in the type system.",
        "Only by using a plugin."
      ],
      "answer": "By using recursive conditional types with template literals to find uppercase letters and insert an underscore.",
      "explanation": "Complex string transformations like Camel to Snake can be implemented using recursion and template literal pattern matching."
    },
    {
      "id": "ts_tl_07",
      "topic": "Template Literals - Numeric Conversion",
      "question": "Can you use template literals to check if a string represents a valid number type-wise?",
      "options": [
        "Yes, `T extends `${number}` ? true : false`",
        "No, only for string characters.",
        "Only if the number is an integer.",
        "Only for specific literals like '1'."
      ],
      "answer": "Yes, `T extends `${number}` ? true : false`",
      "explanation": "The `${number}` placeholder matches any string that can be successfully parsed as a number."
    },
    {
      "id": "ts_tl_08",
      "topic": "Template Literals - CSS Types",
      "question": "How can template literals help in defining CSS property types like '10px' or '5rem'?",
      "options": [
        "type Distance = `${number}${Unit}`; where Unit is a union of units.",
        "They cannot.",
        "By using specific string literals.",
        "By using the CSS-in-JS library."
      ],
      "answer": "type Distance = `${number}${Unit}`; where Unit is a union of units.",
      "explanation": "Template literals allow creating type-safe units by combining numeric strings with unit suffixes."
    },
    {
      "id": "ts_tl_09",
      "topic": "Template Literals - Large Unions",
      "question": "What is a potential downside of using template literals to generate extremely large unions (e.g., all combinations of two large enums)?",
      "options": [
        "It can hit the internal 'complexity' limit and cause the compiler to fail.",
        "It makes the JS code larger.",
        "It only works for strings under 10 characters.",
        "It disables type checking for those variables."
      ],
      "answer": "It can hit the internal 'complexity' limit and cause the compiler to fail.",
      "explanation": "The TS compiler has a limit on the number of members a union can have (usually 100,000) to maintain performance. Cartesian products can quickly exceed this."
    },
    {
      "id": "ts_tl_10",
      "topic": "Template Literals - String Const",
      "question": "What is the inferred type of `` const x = `hello ${name}` `` if `name` is a string variable?",
      "options": [
        "string",
        "`hello ${string}`",
        "any",
        "never"
      ],
      "answer": "string",
      "explanation": "Unless the variable is marked `as const` or the name itself is a string literal type, the template literal usually widens to 'string'."
    }
  ]
}