{
  "message": "Development-Programming Fundamentals - Ts Advanced Features",
  "questions": [
    {
      "id": "ts_tl_01",
      "topic": "Template Literals - String Manipulation",
      "question": "What is the result of `type GetterName<T extends string> = `get${Capitalize<T>}`; type Res = GetterName<'name'>;`?",
      "options": [
        "\"getName\"",
        "\"getname\"",
        "\"Getname\"",
        "string"
      ],
      "answer": "\"getName\"",
      "explanation": "TypeScript provides intrinsic string manipulation types like `Capitalize`, `Uncapitalize`, `Uppercase`, and `Lowercase` that can be used within template literal types."
    },
    {
      "id": "ts_tl_02",
      "topic": "Template Literals - Unions",
      "question": "If `type T = 'a' | 'b'` and `type U = '1' | '2'`, what is the resulting union of `` `${T}_${U}` ``?",
      "options": [
        "\"a_1\" | \"a_2\" | \"b_1\" | \"b_2\"",
        "\"a_1\" | \"b_2\"",
        "string",
        "\"a_b_1_2\""
      ],
      "answer": "\"a_1\" | \"a_2\" | \"b_1\" | \"b_2\"",
      "explanation": "Template literals are distributive over unions. If multiple placeholders are used, the result is the Cartesian product of all union members."
    },
    {
      "id": "ts_sn_01",
      "topic": "Soundness - Excess Property Checks",
      "question": "Why does `const obj: { a: number } = { a: 1, b: 2 };` throw an error, but `const temp = { a: 1, b: 2 }; const obj: { a: number } = temp;` does not?",
      "options": [
        "TypeScript performs 'Excess Property Checks' only on fresh object literals.",
        "The second example is a bug in TypeScript.",
        "The first example uses strict mode.",
        "The second example uses type inference."
      ],
      "answer": "TypeScript performs 'Excess Property Checks' only on fresh object literals.",
      "explanation": "To prevent common mistakes, TS checks for extra properties when an object literal is assigned directly. However, for existing references, it only checks that the required properties exist (structural subtyping)."
    },
    {
      "id": "ts_sn_02",
      "topic": "Soundness - Satisfies",
      "question": "What is the difference between `const c: Color = 'red'` and `const c = 'red' satisfies Color`?",
      "options": [
        "satisfies preserves the specific literal type ('red'), while the annotation widens it to Color.",
        "annotation is faster.",
        "satisfies only works for objects.",
        "There is no difference."
      ],
      "answer": "satisfies preserves the specific literal type ('red'), while the annotation widens it to Color.",
      "explanation": "satisfies validates that a value matches a type without changing the resulting inferred type of the variable."
    },
    {
      "id": "ts_sn_03",
      "topic": "Soundness - Branded Types",
      "question": "How do you implement a 'Branded' type for an Email string to ensure only validated emails can be passed to certain functions?",
      "options": [
        "type Email = string & { readonly __brand: unique symbol };",
        "type Email = string | { brand: string };",
        "interface Email extends String { brand: 'email' }",
        "type Email = Brand<string, 'email'>"
      ],
      "answer": "type Email = string & { readonly __brand: unique symbol };",
      "explanation": "By intersecting string with an object containing a unique key (the 'brand'), you create a type that is structurally a string but conceptually distinct to the TS compiler."
    }
  ]
}