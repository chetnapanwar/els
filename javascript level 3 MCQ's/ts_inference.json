{
  "message": "Development-Programming Fundamentals - Ts Inference",
  "questions": [
    {
      "id": "ts_inf_01",
      "topic": "Infer - Functional Return",
      "question": "Given `type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : any`, what is `MyReturnType<new () => string>`?",
      "options": [
        "string",
        "any",
        "never",
        "MyReturnType"
      ],
      "answer": "any",
      "explanation": "The pattern `(...args: any[]) => infer R` matches functions, but not class constructors. To match a constructor, you would need `new (...args: any[]) => infer R`."
    },
    {
      "id": "ts_inf_02",
      "topic": "Infer - Nested Inference",
      "question": "How do you infer the type of a value inside a nested array, e.g., `string[][]` -> `string`?",
      "options": [
        "type Deep<T> = T extends (infer U)[] ? (U extends (infer V)[] ? V : U) : T;",
        "type Deep<T> = T[number][number];",
        "Both are valid depending on the depth and structure.",
        "Inference only works one level deep."
      ],
      "answer": "Both are valid depending on the depth and structure.",
      "explanation": "Nested `infer` works just like nested conditional types. Indexed access `T[number]` is also a valid way to drill into array elements."
    },
    {
      "id": "ts_inf_03",
      "topic": "Infer - Parameters",
      "question": "What is the result of `type P<T> = T extends (a: infer A, ...args: any[]) => any ? A : never; type Res = P<(x: number, y: string) => void>;`?",
      "options": [
        "number",
        "string",
        "any",
        "never"
      ],
      "answer": "number",
      "explanation": "Inference can be used at any position in a function signature, including individual parameters."
    },
    {
      "id": "ts_var_01",
      "topic": "Variance - Covariance",
      "question": "In TypeScript, simple types like `Dog extends Animal` are considered...",
      "options": [
        "Covariant",
        "Contravariant",
        "Invariant",
        "Bivariant"
      ],
      "answer": "Covariant",
      "explanation": "Covariance means that if A is a subtype of B, then Container<A> is a subtype of Container<B> (for simple containers/properties)."
    },
    {
      "id": "ts_var_02",
      "topic": "Variance - Function Parameters",
      "question": "Under `--strictFunctionTypes`, if `Dog extends Animal`, which is true?",
      "options": [
        "(a: Animal) => void is a subtype of (d: Dog) => void",
        "(d: Dog) => void is a subtype of (a: Animal) => void",
        "They are identical.",
        "Neither is a subtype of the other."
      ],
      "answer": "(a: Animal) => void is a subtype of (d: Dog) => void",
      "explanation": "This is Contravariance. You can safely pass a function that takes a broader type (Animal) to a place that expects a function taking a narrower type (Dog)."
    },
    {
      "id": "ts_var_03",
      "topic": "Variance - Readonly Arrays",
      "question": "Are `readonly Dog[]` and `Dog[]` related in terms of variance?",
      "options": [
        "Dog[] is a subtype of readonly Dog[].",
        "readonly Dog[] is a subtype of Dog[].",
        "They are not related.",
        "They are invariant."
      ],
      "answer": "Dog[] is a subtype of readonly Dog[].",
      "explanation": "A mutable array can always be treated as a readonly array, but a readonly array cannot be used where mutation is expected."
    },
    {
      "id": "ts_var_04",
      "topic": "Variance - Invariance",
      "question": "When does a type parameter become Invariant in TypeScript?",
      "options": [
        "When it is used in both a covariant (output) and contravariant (input) position.",
        "When it is marked as 'private'.",
        "When it is used in a Mapped Type.",
        "It never happens; TS is always bivariant."
      ],
      "answer": "When it is used in both a covariant (output) and contravariant (input) position.",
      "explanation": "If a type is both read from and written to (like in a mutable property `get/set`), the compiler must ensure the types match exactly to maintain soundess."
    },
    {
      "id": "ts_inf_04",
      "topic": "Infer - Generics",
      "question": "Can you infer a type parameter from a custom generic type, e.g., `type ExtractVal<T> = T extends MyBox<infer V> ? V : never`?",
      "options": [
        "Yes",
        "No",
        "Only for built-in types",
        "Only if MyBox is an interface"
      ],
      "answer": "Yes",
      "explanation": "Inference works on any generic structure that the compiler can pattern-match against."
    },
    {
      "id": "ts_inf_05",
      "topic": "Infer - Type Aliases",
      "question": "Where must the `infer` keyword ALWAYS be placed?",
      "options": [
        "Inside the 'extends' clause of a conditional type.",
        "At the start of a type alias.",
        "Inside a generic constraint.",
        "Anywhere a type can be defined."
      ],
      "answer": "Inside the 'extends' clause of a conditional type.",
      "explanation": "The 'infer' keyword is syntactically tied to the condition part of conditional types."
    },
    {
      "id": "ts_var_05",
      "topic": "Variance - Methods vs Properties",
      "question": "Functions declared as 'methods' in an interface (e.g., `f(x: string): void`) behave differently regarding variance than 'property' functions (e.g., `f: (x: string) => void`). How?",
      "options": [
        "Methods are checked bivariantly even under strict mode.",
        "Properties are checked bivariantly.",
        "There is no difference.",
        "Methods cannot be contravariant."
      ],
      "answer": "Methods are checked bivariantly even under strict mode.",
      "explanation": "This is a deliberate design choice in TypeScript's 'strictFunctionTypes' to avoid breaking existing object-oriented patterns, while property functions follow strict contravariance."
    }
  ]
}