{
  "message": "Development-Programming Fundamentals - Js Metaprogramming",
  "questions": [
    {
      "id": "js_meta_01",
      "topic": "Metaprogramming - Proxy Traps",
      "question": "Which Proxy trap is triggered when calling `delete obj.prop`?",
      "options": [
        "deleteProperty",
        "trapDelete",
        "remove",
        "ownKeys"
      ],
      "answer": "deleteProperty",
      "explanation": "The 'deleteProperty' trap intercepts the 'delete' operator on properties."
    },
    {
      "id": "js_meta_02",
      "topic": "Metaprogramming - Reflect API",
      "question": "What is the primary advantage of using `Reflect.set(target, key, value, receiver)` over `target[key] = value` inside a Proxy?",
      "options": [
        "It allows you to correctly pass the 'receiver' (the Proxy) for objects with custom setters.",
        "It is significantly faster.",
        "It automatically validates the value.",
        "It prevents the Proxy from being deleted."
      ],
      "answer": "It allows you to correctly pass the 'receiver' (the Proxy) for objects with custom setters.",
      "explanation": "Just like Reflect.get, Reflect.set accepts a 'receiver' argument to ensure 'this' context inside setters points to the Proxy wrapper."
    },
    {
      "id": "js_meta_03",
      "topic": "Metaprogramming - Symbols",
      "question": "What is the purpose of `Symbol.iterator`?",
      "options": [
        "It defines how an object should be iterated over by 'for...of'.",
        "It converts an object to an array.",
        "It makes the object private.",
        "It creates a unique ID for the object."
      ],
      "answer": "It defines how an object should be iterated over by 'for...of'.",
      "explanation": "Symbol.iterator is a 'well-known symbol' that the JS engine looks for to determine if an object implements the Iterable protocol."
    },
    {
      "id": "js_meta_04",
      "topic": "Metaprogramming - Symbol.for",
      "question": "Which statement is true about `Symbol('foo') === Symbol('foo')`?",
      "options": [
        "Always false",
        "Always true",
        "True only in strict mode",
        "True if defined in the global registry"
      ],
      "answer": "Always false",
      "explanation": "Every call to Symbol() creates a unique symbol, even if the description is the same. Symbol.for('foo') would return the same symbol."
    },
    {
      "id": "js_meta_05",
      "topic": "Metaprogramming - Custom Inspect",
      "question": "How can you customize the output of `JSON.stringify(obj)` for a custom object?",
      "options": [
        "Implement a `toJSON()` method on the object.",
        "Use Symbol.toStringTag.",
        "Use Proxy internally.",
        "It cannot be customized."
      ],
      "answer": "Implement a `toJSON()` method on the object.",
      "explanation": "JSON.stringify checks for a toJSON method and uses its return value as the serialized representation."
    },
    {
      "id": "js_meta_06",
      "topic": "Metaprogramming - Well-known Symbols",
      "question": "Which symbol is used to customize the result of `instanceof`?",
      "options": [
        "Symbol.hasInstance",
        "Symbol.isInstance",
        "Symbol.check",
        "Symbol.prototype"
      ],
      "answer": "Symbol.hasInstance",
      "explanation": "Classes can override [Symbol.hasInstance] to control how instanceof behaves with their instances."
    },
    {
      "id": "js_meta_07",
      "topic": "Metaprogramming - Proxy Revocation",
      "question": "What is a 'Revocable' Proxy?",
      "options": [
        "A Proxy that can be 'shut off', making it throw an error on any further access.",
        "A Proxy that can be deleted.",
        "A Proxy that only works once.",
        "A Proxy that automatically updates the target."
      ],
      "answer": "A Proxy that can be 'shut off', making it throw an error on any further access.",
      "explanation": "Proxy.revocable() returns an object with a 'proxy' and a 'revoke' function. Once revoke is called, the proxy becomes unusable."
    },
    {
      "id": "js_meta_08",
      "topic": "Metaprogramming - Reflect Metadata",
      "question": "Is `Reflect.defineMetadata` a native part of the ECMAScript standard as of 2024?",
      "options": [
        "No, it is an experimental proposal commonly used in libraries like InversifyJS or TypeORM.",
        "Yes, it was added in ES2020.",
        "Yes, it is part of the Proxy specification.",
        "No, it is a Node.js specific API."
      ],
      "answer": "No, it is an experimental proposal commonly used in libraries like InversifyJS or TypeORM.",
      "explanation": "The Metadata Reflection API is still a proposal and requires a polyfill like 'reflect-metadata' to work."
    },
    {
      "id": "js_meta_09",
      "topic": "Metaprogramming - Property Observation",
      "question": "Which Proxy trap allows you to control which property names are returned by `Object.keys()`?",
      "options": [
        "ownKeys",
        "getOwnPropertyDescriptor",
        "enumerate",
        "getKeys"
      ],
      "answer": "ownKeys",
      "explanation": "The ownKeys trap intercepts Object.getOwnPropertyNames(), Object.getOwnPropertySymbols(), and Object.keys()."
    },
    {
      "id": "js_meta_10",
      "topic": "Metaprogramming - Symbol.species",
      "question": "What is `Symbol.species` used for?",
      "options": [
        "Specifying which constructor to use when creating derived objects (e.g., in Array.map).",
        "Identifying the class of an object.",
        "Comparing two objects for equality.",
        "Deeply cloning an object."
      ],
      "answer": "Specifying which constructor to use when creating derived objects (e.g., in Array.map).",
      "explanation": "It allows a derived class to specify which constructor should be used for methods that return new instances of the same 'species' (like map, filter, or slice)."
    }
  ]
}