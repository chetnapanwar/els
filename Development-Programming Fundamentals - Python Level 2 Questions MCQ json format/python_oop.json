[
    {
        "id": "py_oop_01",
        "topic": "OOP - Inheritance",
        "level": 2,
        "question": "What is the Method Resolution Order (MRO) in Python?",
        "options": [
            "The order in which Python looks for a method in a hierarchy of classes.",
            "The order in which methods are defined in a class.",
            "The order in which classes are instantiated.",
            "A sorting algorithm for lists."
        ],
        "answer": "The order in which Python looks for a method in a hierarchy of classes.",
        "explanation": "MRO determines where Python looks for a method when it is called on an object, especially in multiple inheritance scenarios (resolves left-to-right, depth-first but handling diamonds via C3 linearization)."
    },
    {
        "id": "py_oop_02",
        "topic": "OOP - super()",
        "level": 2,
        "question": "What is the primary purpose of `super().__init__()` inside a subclass constructor?",
        "options": [
            "To initialize the parent class(es) correctly.",
            "To create a new instance of the parent class.",
            "To prevent the parent class from initializing.",
            "To copy methods from the parent class."
        ],
        "answer": "To initialize the parent class(es) correctly.",
        "explanation": "It delegates initialization to the parent class, ensuring that inherited attributes are set up properly."
    },
    {
        "id": "py_oop_03",
        "topic": "OOP - Magic Methods",
        "level": 2,
        "question": "Which magic method is called when `str(obj)` is used?",
        "options": [
            "__str__",
            "__repr__",
            "__string__",
            "__init__"
        ],
        "answer": "__str__",
        "explanation": "`__str__` is intended to return a readable string representation for end-users. `__repr__` is for developers."
    },
    {
        "id": "py_oop_04",
        "topic": "OOP - Class vs Instance Attributes",
        "level": 2,
        "question": "If you modify a *mutable* class attribute (like a list) using one instance, what happens?",
        "options": [
            "The change is reflected across all instances that share that class attribute.",
            "Only that specific instance changes.",
            "Python creates a copy for that instance.",
            "It raises an error."
        ],
        "answer": "The change is reflected across all instances that share that class attribute.",
        "explanation": "Class attributes are shared. Modifying a mutable object stored in a class attribute affects all instances. Assigning a new value (`obj.attr = ...`) would create an instance attribute, shadowing the class one."
    },
    {
        "id": "py_oop_05",
        "topic": "OOP - Private Members",
        "level": 2,
        "question": "How does Python handle 'private' attributes beginning with double underscores (e.g., `__hidden`)?",
        "options": [
            "It performs name mangling (renames it to `_ClassName__hidden`).",
            "It makes them strictly inaccessible from outside.",
            "It is just a convention and does nothing.",
            "It throws a permission error on access."
        ],
        "answer": "It performs name mangling (renames it to `_ClassName__hidden`).",
        "explanation": "Python does not have true 'private' members. Double underscore prefixes trigger name mangling to prevent accidental overwrites in subclasses."
    },
    {
        "id": "py_oop_06",
        "topic": "OOP - Static Methods",
        "level": 2,
        "question": "What is the difference between `@staticmethod` and `@classmethod`?",
        "options": [
            "@classmethod receives the class (`cls`) as the first argument; @staticmethod receives no implicit first argument.",
            "@staticmethod receives `self`; @classmethod receives `cls`.",
            "@staticmethod cannot be called on instances.",
            "There is no difference."
        ],
        "answer": "@classmethod receives the class (`cls`) as the first argument; @staticmethod receives no implicit first argument.",
        "explanation": "Static methods are just inherited functions. Class methods operate on the class itself (e.g., for factory methods)."
    },
    {
        "id": "py_oop_07",
        "topic": "OOP - __new__ vs __init__",
        "level": 2,
        "question": "Which method is responsible for *creating* the object instance?",
        "options": [
            "__new__",
            "__init__",
            "__create__",
            "__make__"
        ],
        "answer": "__new__",
        "explanation": "`__new__` creates and returns the instance. `__init__` initializes the attributes of that instance after it has been created."
    },
    {
        "id": "py_oop_08",
        "topic": "OOP - Property Decorator",
        "level": 2,
        "question": "What does the `@property` decorator allow you to do?",
        "options": [
            "Access a method like an attribute (without parentheses).",
            "Make a method private.",
            "Speed up method execution.",
            "Define a type hint."
        ],
        "answer": "Access a method like an attribute (without parentheses).",
        "explanation": "It allows you to define getter (and setter/deleter) logic while exposing a clean attribute-access API."
    },
    {
        "id": "py_oop_09",
        "topic": "OOP - Abstract Base Classes",
        "level": 2,
        "question": "Which module allows you to define Abstract Base Classes (ABCs)?",
        "options": [
            "abc",
            "abstract",
            "oop",
            "types"
        ],
        "answer": "abc",
        "explanation": "The `abc` module (Abstract Base Classes) provides the `ABC` class and `@abstractmethod` decorator."
    },
    {
        "id": "py_oop_10",
        "topic": "OOP - Isinstance",
        "level": 2,
        "question": "Does `isinstance(obj, ClassA)` return True if `obj` is an instance of a subclass of `ClassA`?",
        "options": [
            "Yes",
            "No",
            "Only if strict=False",
            "Only in Python 2"
        ],
        "answer": "Yes",
        "explanation": "`isinstance()` checks for inheritance. `type(obj) is ClassA` checks for exact type match."
    }
]