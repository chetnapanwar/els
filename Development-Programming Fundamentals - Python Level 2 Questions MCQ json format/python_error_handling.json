[
    {
        "id": "py_err_01",
        "topic": "Errors - Try Except Else",
        "level": 2,
        "question": "When is the `else` block in a `try...except...else` structure executed?",
        "options": [
            "Only if no exception was raised in the `try` block.",
            "Always, regardless of exceptions.",
            "Only if an exception occurred.",
            "When the `finally` block fails."
        ],
        "answer": "Only if no exception was raised in the `try` block.",
        "explanation": "The `else` block allows you to execute code that should only run if the sensitive operation succeeded, keeping the `try` block focused on the error-prone code."
    },
    {
        "id": "py_err_02",
        "topic": "Errors - Finally",
        "level": 2,
        "question": "Does the `finally` block run if the function `return`s inside the `try` block?",
        "options": [
            "Yes, always.",
            "No, the function exits immediately.",
            "Only if an exception happens.",
            "Only if `sys.exit()` is not called."
        ],
        "answer": "Yes, always.",
        "explanation": "The `finally` block is guaranteed to execute (for cleanup purposes) before leaving the scope, even if a return statement, break, or continue is encountered."
    },
    {
        "id": "py_err_03",
        "topic": "Errors - Custom Exceptions",
        "level": 2,
        "question": "How do you create a custom exception class?",
        "options": [
            "Inherit from `Exception` (or a subclass).",
            "Use the `raise` keyword.",
            "Define a function named `Error`.",
            "Inherit from `object`."
        ],
        "answer": "Inherit from `Exception` (or a subclass).",
        "explanation": "All custom exceptions should inherit from the built-in `Exception` class to integrate properly with the `try...except` mechanism."
    },
    {
        "id": "py_err_04",
        "topic": "File I/O - Context Managers",
        "level": 2,
        "question": "What is the main benefit of using `with open(...) as f:`?",
        "options": [
            "It automatically closes the file, even if an error occurs.",
            "It is faster.",
            "It allows reading and writing simultaneously.",
            "It compresses the file."
        ],
        "answer": "It automatically closes the file, even if an error occurs.",
        "explanation": "The `with` statement uses the Context Manager protocol (`__enter__` and `__exit__`). The `__exit__` method ensures resources are released."
    },
    {
        "id": "py_err_05",
        "topic": "File I/O - Modes",
        "level": 2,
        "question": "Which file mode opens a file for writing, creating it if it doesn't exist, and truncating it (clearing content) if it does?",
        "options": [
            "'w'",
            "'a'",
            "'r+'",
            "'x'"
        ],
        "answer": "'w'",
        "explanation": "'w' stands for write. Be careful as it deletes existing content. 'a' appends. 'x' creates only if it doesn't exist."
    },
    {
        "id": "py_err_06",
        "topic": "Errors - Raising",
        "level": 2,
        "question": "How do you re-raise the active exception inside an `except` block?",
        "options": [
            "raise",
            "raise Exception",
            "return",
            "continue"
        ],
        "answer": "raise",
        "explanation": "Using `raise` without arguments inside an `except` block re-raises the exact exception that was caught, preserving the stack trace."
    },
    {
        "id": "py_err_07",
        "topic": "File I/O - Reading Lines",
        "level": 2,
        "question": "Which method reads the entire file into a list of strings?",
        "options": [
            "readlines()",
            "read()",
            "readline()",
            "scan()"
        ],
        "answer": "readlines()",
        "explanation": "`readlines()` (plural) returns a list where each element is a line. `read()` returns one giant string."
    },
    {
        "id": "py_err_08",
        "topic": "Errors - Hierarchy",
        "level": 2,
        "question": "Which exception catches *almost everything*, including KeyboardInterrupt?",
        "options": [
            "BaseException",
            "Exception",
            "Error",
            "Object"
        ],
        "answer": "BaseException",
        "explanation": "`BaseException` is the root of the hierarchy. `Exception` is the parent of all non-system-exiting exceptions. Usually, you should catch `Exception`, not `BaseException`."
    },
    {
        "id": "py_err_09",
        "topic": "File I/O - Binary Mode",
        "level": 2,
        "question": "What mode should you use to copy an image file?",
        "options": [
            "'rb' and 'wb'",
            "'r' and 'w'",
            "'img'",
            "'copy'"
        ],
        "answer": "'rb' and 'wb'",
        "explanation": "You must use binary mode ('b') for non-text files to prevent encoding issues or line-ending conversions."
    },
    {
        "id": "py_err_10",
        "topic": "Errors - Assert",
        "level": 2,
        "question": "What happens if an `assert` statement fails?",
        "options": [
            "It raises an AssertionError.",
            "It prints a warning.",
            "It stops the debugger.",
            "It returns False."
        ],
        "answer": "It raises an AssertionError.",
        "explanation": "Asserts are used for debugging/sanity checks. If the condition is false, `AssertionError` is raised."
    }
]